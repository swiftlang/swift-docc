<!doctype html><html lang="en-US" class="no-js"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><link rel="icon" href="/swift-docc/favicon.ico"><link rel="mask-icon" href="/swift-docc/favicon.svg" color="#333333"><title>Concurrency</title><script>var baseUrl = "/swift-docc/"</script><script defer="defer" src="/swift-docc/js/chunk-vendors.0b7dc663.js"></script><script defer="defer" src="/swift-docc/js/index.54db7914.js"></script><link href="/swift-docc/css/index.19043b1e.css" rel="stylesheet"><meta content="Perform concurrent work on the DocC model." name="description"/></head><body data-color-scheme="auto"><noscript><article><section><ul><li><a href="../index.html">SwiftDocC</a></li><li>Concurrency</li></ul><p id="eyebrow">Article</p><h1>Concurrency</h1><p id="abstract">Perform concurrent work on the DocC model.</p></section><h2>Overview</h2><p>DocC is, generally speaking, performing a sequence of operations on a set of documentation topics. Since the compilation is a pipeline, you mostly do work serially as each stage’s input is the previous stage’s output.</p><p>When working serially becomes a bottleneck, use a suitable method from a small number of <code>Collection</code> extensions that synchronously perform concurrent work on multiple threads but keep the complexity of your code manageable.</p><p>The preferred way to concurrently perform work is to have a function called from within the main queue, perform concurrent operations inside the function, and return the aggregated results, keeping the concurrency within the local scope of the function.</p><p>When you would like to concurrently perform work on a collection of inputs you have a choice between:</p><ul><li><p><code>Collection.concurrentPerform(batches:block:)</code> concurrently perform a block of code over the collection elements. A concurrent alternative to <code>Collection.forEach(_:)</code>.</p></li><li><p><code>Collection.concurrentPerform(batches:block:) -&gt; [Result]</code> concurrently perform a block over the collection elements and optionally return an arbitrary amount of results returned in no particular order.</p></li><li><p><code>Collection.concurrentMap(batches:block:) -&gt; [Result]</code> concurrently convert the collection elements; the returned results are in the collection’s original order. A concurrent alternative to <code>Collection.map(_:)</code>.</p></li></ul><p>To concurrently convert a set of elements and preserve the order in the results use:</p><pre class="swift"><code>let results: [Int] = [1, 2, 3, 4].concurrentMap {
  return $0 * 2
}
</code></pre><p>To return an arbitrary amount of results in no particular order use:</p><pre class="swift"><code>let errors: [Error] = [1, 2, 3, 4].concurrentPerform { element, results in
  if element % 2 == 0 {
    results.append(MyError.evenInput)
  }
}
</code></pre></article></noscript><div id="app"></div></body></html>