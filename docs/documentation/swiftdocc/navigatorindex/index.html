<!doctype html><html lang="en-US" class="no-js"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><link rel="icon" href="/swift-docc/favicon.ico"><link rel="mask-icon" href="/swift-docc/favicon.svg" color="#333333"><title>NavigatorIndex</title><script>var baseUrl = "/swift-docc/"</script><script defer="defer" src="/swift-docc/js/chunk-vendors.0b7dc663.js"></script><script defer="defer" src="/swift-docc/js/index.54db7914.js"></script><link href="/swift-docc/css/index.19043b1e.css" rel="stylesheet"><meta content="A `NavigatorIndex` contains all the necessary information to display the data inside a navigator. The data ranges from the tree to the necessary pieces of information to filter the content and perform actions in a fast way. A navigator index is created per bundle and needs a bundle identifier to correctly work. Anonymous bundles are allowed, but they limit the functionalities of the index." name="description"/></head><body data-color-scheme="auto"><noscript><article><section><ul><li><a href="../index.html">SwiftDocC</a></li><li>NavigatorIndex</li></ul><p>Class</p><h1>NavigatorIndex</h1><p>A <code>NavigatorIndex</code> contains all the necessary information to display the data inside a navigator. The data ranges from the tree to the necessary pieces of information to filter the content and perform actions in a fast way. A navigator index is created per bundle and needs a bundle identifier to correctly work. Anonymous bundles are allowed, but they limit the functionalities of the index.</p><pre><code>class NavigatorIndex</code></pre></section><h2>Discussion</h2><p>A <code>NavigatorIndex</code> is composed by two main components:</p><ul><li><p>A navigator tree reflecting the content curation</p></li><li><p>An availability index storing the information about for which platform and SDK a given symbol is available and they map USR to document’s path</p></li></ul><p>The two mentioned components are generated by using a <code>NavigatorIndex.Builder</code> instance, which indexes the content accordingly to the desired configuration. A <code>NavigatorIndex</code> can be stored on disk to be later loaded. Loading an index can be performed in a single operation (synchronous) or asynchronously. This option is extremely useful in case an application needs to load a very large amount of data while updating the UI to let the user navigate the loaded content, while the remaining is loaded in a background thread and presented later in time.</p><p>There are few important pieces information a <code>NavigatorIndex</code> requires to properly work:</p><ul><li><p>A bundle identifier</p></li><li><p>A valid LMDB database for storing availability information</p></li><li><p>A valid navigator tree</p></li></ul><p>Building an index with one of the mentioned components is not supported.</p><h2>Topics</h2><h3>Creating an index</h3><p></p><ul><li><a href="readnavigatorindex(url:bundleidentifier:readnavigatortree:presentationidentifier:onnoderead:)/index.html"><code>static func readNavigatorIndex(url: URL, bundleIdentifier: String?, readNavigatorTree: Bool, presentationIdentifier: String?, onNodeRead: ((NavigatorTree.Node) -&gt; Void)?) throws -&gt; NavigatorIndex</code><p>Initializes a <code>NavigatorIndex</code> from a given path on disk.</p></a></li></ul><h3>Classes</h3><ul><li><a href="builder/index.html"><code>class Builder</code><p>A <code>Builder</code> is a utility class to build a navigator index.</p></a></li></ul><h3>Structures</h3><ul><li><a href="identifier/index.html"><code>struct Identifier</code><p>A unique identifier for navigator index items.</p></a></li></ul><h3>Instance Properties</h3><ul><li><a href="availabilityindex/index.html"><code>let availabilityIndex: AvailabilityIndex</code><p>The availability index.</p></a></li><li><a href="bundleidentifier/index.html"><code>var bundleIdentifier: String</code><p>Bundle Identifier.</p></a></li><li><a href="count/index.html"><code>var count: Int</code><p>The number of item indexed.</p></a></li><li><a href="languagemasktolanguage/index.html"><code>var languageMaskToLanguage: [UInt8 : InterfaceLanguage]</code><p>The mapping from a single language mask to its interface language type.</p></a></li><li><a href="languages/index.html"><code>var languages: [String]</code><p>The available languages in the index.</p></a></li><li><a href="navigatortree/index.html"><code>let navigatorTree: NavigatorTree</code><p>The navigator tree.</p></a></li><li><a href="presentationidentifier/index.html"><code>let presentationIdentifier: String?</code><p>A presentation identifier used to disambiguate content in presentation contexts.</p></a></li><li><a href="url/index.html"><code>let url: URL</code><p>The url of the index.</p></a></li></ul><h3>Instance Methods</h3><ul><li><a href="availabilities(for:)/index.html"><code>func availabilities(for: UInt64) -&gt; [AvailabilityIndex.Info]</code><p>Returns an array of availabilities based on a single id.</p></a></li><li><a href="id(for:with:)/index.html"><code>func id(for: String, with: InterfaceLanguage) -&gt; UInt32?</code><p>If available, returns the ID of a path for the given language.</p></a></li><li><a href="path(for:)/index.html"><code>func path(for: UInt32) -&gt; String?</code><p>If available, returns the path from the numeric ID inside the navigator tree.</p></a></li><li><a href="path(for:language:hashed:)/index.html"><code>func path(for: String, language: InterfaceLanguage, hashed: Bool) -&gt; String?</code><p>Returns the path of a given USR if existing.</p></a></li><li><a href="readnavigatortree(timeout:delay:queue:broadcast:)/index.html"><code>func readNavigatorTree(timeout: TimeInterval, delay: TimeInterval, queue: DispatchQueue, broadcast: NavigatorTree.BroadcastCallback?) throws</code><p>Read a tree on disk from a given path. The read is atomically performed, which means it reads all the content of the file from the disk and process the tree from loaded data. The queue is used to load the data for a given timeout period, after that, the queue is used to schedule another read after a given delay. This approach ensures that the used queue doesn’t stall while loading the content from the disk keeping the used queue responsive.</p></a></li></ul><h3>Type Properties</h3><ul><li><a href="unknownbundleidentifier/index.html"><code>static let UnknownBundleIdentifier: String</code><p>A string indicating an unknown bundle identifier.</p></a></li><li><a href="bundlekey/index.html"><code>static let bundleKey: String</code><p>The key used to store the name of the bundle inside the database.</p></a></li><li><a href="itemsindexkey/index.html"><code>static let itemsIndexKey: String</code><p>The key used to store the number of indexed items.</p></a></li><li><a href="pathhasherkey/index.html"><code>static let pathHasherKey: String</code><p>The key used to store the name of path hasher inside the database.</p></a></li></ul><h3>Enumerations</h3><ul><li><a href="error/index.html"><code>enum Error</code><p>A specific error to describe issues when processing a <code>NavigatorIndex</code>.</p></a></li><li><a href="pagetype/index.html"><code>enum PageType</code><p>Indicates the page type of a given item inside the tree.</p></a></li></ul></article></noscript><div id="app"></div></body></html>