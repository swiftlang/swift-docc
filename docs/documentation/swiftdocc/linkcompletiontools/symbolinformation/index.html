<!doctype html><html lang="en-US" class="no-js"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><link rel="icon" href="/swift-docc/favicon.ico"><link rel="mask-icon" href="/swift-docc/favicon.svg" color="#333333"><title>LinkCompletionTools.SymbolInformation</title><script>var baseUrl = "/swift-docc/"</script><script defer="defer" src="/swift-docc/js/chunk-vendors.0b7dc663.js"></script><script defer="defer" src="/swift-docc/js/index.54db7914.js"></script><link href="/swift-docc/css/index.19043b1e.css" rel="stylesheet"><meta content="Information about a symbol for link completion purposes." name="description"/></head><body data-color-scheme="auto"><noscript><article><section><ul><li><a href="../../index.html">SwiftDocC</a></li><li><a href="../index.html">LinkCompletionTools</a></li><li>LinkCompletionTools.SymbolInformation</li></ul><p>Structure</p><h1>LinkCompletionTools.SymbolInformation</h1><p>Information about a symbol for link completion purposes.</p><pre><code>struct SymbolInformation</code></pre></section><h2>Discussion</h2><blockquote class="aside note"><p class="label">Note</p><p> This symbol information doesn’t include the name. It’s the callers responsibility to group symbols by their name.</p></blockquote><blockquote class="aside important"><p class="label">Important</p><p> It’s the callers responsibility to create symbol information that matches what the compilers emit in symbol graph files. If there are mismatches, DocC may suggest disambiguation that won’t resolve with the real compiler emitted symbol data.</p></blockquote><h2>Topics</h2><h3>Initializers</h3><ul><li><a href="init(kind:symbolidhash:parametertypes:returntypes:)/index.html"><code>init(kind: String, symbolIDHash: String, parameterTypes: [String]?, returnTypes: [String]?)</code></a></li><li><a href="init(symbol:)/index.html"><code>init(symbol: SymbolGraph.Symbol)</code></a></li></ul><h3>Instance Properties</h3><ul><li><a href="kind/index.html"><code>var kind: String</code><p>The kind of symbol, for example <code>"class"</code> or <code>"func.op</code>.</p></a></li><li><a href="parametertypes/index.html"><code>var parameterTypes: [String]?</code><p>The type names of this symbol’s parameters, or <code>nil</code> if this symbol has no function signature information.</p></a></li><li><a href="returntypes/index.html"><code>var returnTypes: [String]?</code><p>The type names of this symbol’s return value, or <code>nil</code> if this symbol has no function signature information.</p></a></li><li><a href="symbolidhash/index.html"><code>var symbolIDHash: String</code><p>A hash of the symbol’s unique identifier.</p></a></li></ul><h3>Instance Methods</h3><ul><li><a href="matches(_:)/index.html"><code>func matches(LinkCompletionTools.ParsedDisambiguation) -&gt; Bool</code><p>Returns a Boolean value that indicates whether this symbol information matches the parsed disambiguation from one of the link components of a parsed link string.</p></a></li></ul><h3>Type Methods</h3><ul><li><a href="hash(uniquesymbolid:)/index.html"><code>static func hash(uniqueSymbolID: String) -&gt; String</code><p>Creates a hashed representation of a symbol’s unique identifier.</p></a></li></ul></article></noscript><div id="app"></div></body></html>