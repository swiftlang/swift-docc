<!doctype html><html lang="en-US" class="no-js"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><link rel="icon" href="/swift-docc/favicon.ico"><link rel="mask-icon" href="/swift-docc/favicon.svg" color="#333333"><title>ResolvedTopicReference</title><script>var baseUrl = "/swift-docc/"</script><script defer="defer" src="/swift-docc/js/chunk-vendors.0b7dc663.js"></script><script defer="defer" src="/swift-docc/js/index.54db7914.js"></script><link href="/swift-docc/css/index.19043b1e.css" rel="stylesheet"><meta content="A reference to a piece of documentation which has been verified to exist." name="description"/></head><body data-color-scheme="auto"><noscript><article><section><ul><li><a href="../index.html">SwiftDocC</a></li><li>ResolvedTopicReference</li></ul><p>Structure</p><h1>ResolvedTopicReference</h1><p>A reference to a piece of documentation which has been verified to exist.</p><pre><code>struct ResolvedTopicReference</code></pre></section><h2>Discussion</h2><p>A <code>ResolvedTopicReference</code> refers to some piece of documentation, such as an article or symbol. Once an <code>UnresolvedTopicReference</code> has been resolved to this type, it should be guaranteed that the content backing the documentation is available (i.e. there is a file on disk or data in memory ready to be recalled at any time).</p><h2>Implementation Details</h2><p><code>ResolvedTopicReference</code> is effectively a wrapper around Foundation’s <code>URL</code> and, because of this, it exposes an API very similar to <code>URL</code> and does not allow direct modification of its properties. This immutability brings performance benefits and communicates with user’s of the API that doing something like adding a path component is a potentially expensive operation, just as it is on <code>URL</code>.</p><blockquote class="aside important"><p class="label">Important</p><p>This type has copy-on-write semantics and wraps an underlying class to store its data.</p></blockquote><h2>Topics</h2><h3>Operators</h3><ul><li><a href="==(_:_:)/index.html"><code>static func == (ResolvedTopicReference, ResolvedTopicReference) -&gt; Bool</code></a></li></ul><h3>Initializers</h3><ul><li><a href="init(bundleid:path:fragment:sourcelanguage:)/index.html"><code>init(bundleID: DocumentationBundle.Identifier, path: String, fragment: String?, sourceLanguage: SourceLanguage)</code></a></li><li><a href="init(bundleid:path:fragment:sourcelanguages:)/index.html"><code>init(bundleID: DocumentationBundle.Identifier, path: String, fragment: String?, sourceLanguages: Set&lt;SourceLanguage&gt;)</code></a></li><li><a href="init(from:)/index.html"><code>init(from: any Decoder) throws</code></a></li></ul><h3>Instance Properties</h3><ul><li><a href="bundleid/index.html"><code>var bundleID: DocumentationBundle.Identifier</code><p>The identifier of the bundle that owns this documentation topic.</p></a></li><li><a href="description/index.html"><code>var description: String</code></a></li><li><a href="fragment/index.html"><code>var fragment: String?</code><p>A URL fragment referring to a resource in the topic.</p></a></li><li><a href="lastpathcomponent/index.html"><code>var lastPathComponent: String</code><p>The last path component of this topic reference.</p></a></li><li><a href="path/index.html"><code>var path: String</code><p>The absolute path from the bundle to this topic, delimited by <code>/</code>.</p></a></li><li><a href="sourcelanguage/index.html"><code>var sourceLanguage: SourceLanguage</code><p>The source language for which this topic is relevant.</p></a></li><li><a href="sourcelanguages/index.html"><code>var sourceLanguages: Set&lt;SourceLanguage&gt;</code><p>The source languages for which this topic is relevant.</p></a></li><li><a href="url/index.html"><code>var url: URL</code><p>The topic URL as you would write in a link.</p></a></li></ul><h3>Instance Methods</h3><ul><li><a href="addingsourcelanguages(_:)/index.html"><code>func addingSourceLanguages(Set&lt;SourceLanguage&gt;) -&gt; ResolvedTopicReference</code><p>Returns a topic reference based on the current one that includes the given source languages.</p></a></li><li><a href="appendingpath(_:)/index.html"><code>func appendingPath(String) -&gt; ResolvedTopicReference</code><p>Creates a new topic reference by appending a path to this reference.</p></a></li><li><a href="appendingpathofreference(_:)/index.html"><code>func appendingPathOfReference(UnresolvedTopicReference) -&gt; ResolvedTopicReference</code><p>Creates a new topic reference by appending the path of another topic reference to this reference.</p></a></li><li><a href="encode(to:)/index.html"><code>func encode(to: any Encoder) throws</code></a></li><li><a href="hash(into:)/index.html"><code>func hash(into: inout Hasher)</code></a></li><li><a href="removinglastpathcomponent()/index.html"><code>func removingLastPathComponent() -&gt; ResolvedTopicReference</code><p>Creates a new topic reference by removing the last path component from this topic reference.</p></a></li><li><a href="withfragment(_:)/index.html"><code>func withFragment(String?) -&gt; ResolvedTopicReference</code><p>Creates a new topic reference with the given fragment.</p></a></li><li><a href="withsourcelanguages(_:)/index.html"><code>func withSourceLanguages(Set&lt;SourceLanguage&gt;) -&gt; ResolvedTopicReference</code><p>Returns a topic reference based on the current one but with the given source languages.</p></a></li></ul><h3>Type Properties</h3><ul><li><a href="urlscheme/index.html"><code>static let urlScheme: String</code><p>The URL scheme for <code>doc://</code> links.</p></a></li></ul><h3>Type Methods</h3><ul><li><a href="urlhasresolvedtopicscheme(_:)/index.html"><code>static func urlHasResolvedTopicScheme(URL?) -&gt; Bool</code><p>Returns <code>true</code> if the passed <code>URL</code> has a “doc” URL scheme.</p></a></li></ul></article></noscript><div id="app"></div></body></html>